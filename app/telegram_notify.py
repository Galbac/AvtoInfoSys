import os
import requests
from concurrent.futures import ThreadPoolExecutor
from threading import Lock
from dotenv import load_dotenv

from app.logger import get_logger
from app.utils import load_recipients

load_dotenv()
logger = get_logger()

BOT_TOKEN = os.getenv("BOT_TOKEN")
_lock = Lock()

def is_internet_available(url: str = "https://api.telegram.org", timeout: int = 3) -> bool:
    """ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÑ‚ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð¾ÑÑ‚ÑŒ Ð¸Ð½Ñ‚ÐµÑ€Ð½ÐµÑ‚Ð° Ð¿Ð¾ URL Ñ Ñ‚Ð°Ð¹Ð¼Ð°ÑƒÑ‚Ð¾Ð¼."""
    try:
        response = requests.get(url, timeout=timeout)
        # 200 OK Ð¸ 404 Not Found ÑÑ‡Ð¸Ñ‚Ð°ÐµÐ¼ ÐºÐ°Ðº Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð¾ÑÑ‚ÑŒ API Telegram
        return response.status_code in (200, 404)
    except requests.RequestException:
        return False


def send_to_user(user_id: int, content: str, user_ids: list[int], is_file: bool = False) -> bool:
    """
    ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÑ‚ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð¸Ð»Ð¸ Ñ„Ð°Ð¹Ð» Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŽ Ñ‡ÐµÑ€ÐµÐ· Telegram Bot API.
    ÐŸÑ€Ð¸ Ð¾ÑˆÐ¸Ð±ÐºÐµ 403 ÑƒÐ´Ð°Ð»ÑÐµÑ‚ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð¸Ð· ÑÐ¿Ð¸ÑÐºÐ° user_ids.

    :param user_id: ID Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Telegram
    :param content: Ñ‚ÐµÐºÑÑ‚ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ Ð¸Ð»Ð¸ Ð¿ÑƒÑ‚ÑŒ Ðº Ñ„Ð°Ð¹Ð»Ñƒ
    :param user_ids: Ð¾Ð±Ñ‰Ð¸Ð¹ ÑÐ¿Ð¸ÑÐ¾Ðº Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹ Ð´Ð»Ñ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ Ð¿Ñ€Ð¸ Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²ÐºÐµ
    :param is_file: ÐµÑÐ»Ð¸ True, Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÑ‚ÑÑ Ñ„Ð°Ð¹Ð»
    :return: True Ð¿Ñ€Ð¸ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾Ð¹ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐµ, Ð¸Ð½Ð°Ñ‡Ðµ False
    """
    if not BOT_TOKEN:
        logger.error("âŒ BOT_TOKEN Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½ Ð² .env Ñ„Ð°Ð¹Ð»Ðµ.")
        return False

    base_url = f"https://api.telegram.org/bot{BOT_TOKEN}"
    url = f"{base_url}/sendDocument" if is_file else f"{base_url}/sendMessage"

    data = {"chat_id": user_id}
    files = None

    try:
        if is_file:
            with open(content, "rb") as file:
                files = {"document": file}
                response = requests.post(url, data=data, files=files, timeout=10)
        else:
            data["text"] = content
            response = requests.post(url, data=data, timeout=10)
    except Exception as e:
        logger.error(f"âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐµ {'Ñ„Ð°Ð¹Ð»Ð°' if is_file else 'ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ'} Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŽ {user_id}: {e}")
        return False

    if response.ok:
        logger.info(f"ðŸ“¤ {'ÐžÑ‚Ñ‡ÐµÑ‚' if is_file else 'Ð¡Ð¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ'} Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŽ {user_id}")
        return True
    else:
        logger.error(f"âŒ ÐžÑ‚Ð²ÐµÑ‚ Telegram: {response.status_code} {response.text}")
        if response.status_code == 403:
            with _lock:
                if user_id in user_ids:
                    user_ids.remove(user_id)
                    logger.warning(f"ðŸš« ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ {user_id} ÑƒÐ´Ð°Ð»Ñ‘Ð½ Ð¸Ð· ÑÐ¿Ð¸ÑÐºÐ° (Ð·Ð°Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ð» Ð±Ð¾Ñ‚Ð°)")
        return False


def send_summary_to_telegram(all_results, all_stats, dry_run: bool = False) -> None:
    """
    ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÑ‚ Ð¸Ñ‚Ð¾Ð³Ð¾Ð²Ð¾Ðµ Ñ‚ÐµÐºÑÑ‚Ð¾Ð²Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð²ÑÐµÐ¼ Ð¿Ð¾Ð»ÑƒÑ‡Ð°Ñ‚ÐµÐ»ÑÐ¼ Ð¸Ð· ÑÐ¿Ð¸ÑÐºÐ°.
    Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ Ð¿ÑƒÐ» Ð¿Ð¾Ñ‚Ð¾ÐºÐ¾Ð² Ð´Ð»Ñ Ð¿Ð°Ñ€Ð°Ð»Ð»ÐµÐ»ÑŒÐ½Ð¾Ð¹ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¸.
    """
    if not BOT_TOKEN:
        logger.error("âŒ BOT_TOKEN Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½ Ð² .env Ñ„Ð°Ð¹Ð»Ðµ.")
        return
    if not is_internet_available():
        logger.warning("âš ï¸ ÐÐµÑ‚ Ð¸Ð½Ñ‚ÐµÑ€Ð½ÐµÑ‚Ð°. ÐŸÑ€Ð¾Ð¿ÑƒÑÐº Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¸ Telegram-ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ.")
        return

    user_ids = load_recipients()
    if not user_ids:
        logger.warning("âš ï¸ ÐÐµÑ‚ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹ Ð´Ð»Ñ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¸.")
        return

    message = "ðŸ§ª [Dry Run]\nðŸ“ Ð¡Ð¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð°." if dry_run else "ðŸ“ Ð¡Ð¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð°."
    logger.info(f"ðŸ“¤ ÐžÑ‚Ð¿Ñ€Ð°Ð²ÐºÐ° Ð¸Ñ‚Ð¾Ð³Ð¾Ð²Ð¾Ð³Ð¾ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ ({len(user_ids)} Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹)...")

    with ThreadPoolExecutor(max_workers=min(len(user_ids), 30)) as executor:
        # Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ ÐºÐ¾Ð¿Ð¸ÑŽ ÑÐ¿Ð¸ÑÐºÐ°, Ñ‚.Ðº. Ð¾Ð½ Ð¼Ð¾Ð¶ÐµÑ‚ Ð¸Ð·Ð¼ÐµÐ½ÑÑ‚ÑŒÑÑ Ð² send_to_user
        for user_id in user_ids.copy():
            executor.submit(send_to_user, user_id, message, user_ids, is_file=False)


def send_report_file_to_telegram(report_path: str) -> bool:
    """
    ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÑ‚ Ñ„Ð°Ð¹Ð» Ð¾Ñ‚Ñ‡Ñ‘Ñ‚Ð° Ð²ÑÐµÐ¼ Ð¿Ð¾Ð»ÑƒÑ‡Ð°Ñ‚ÐµÐ»ÑÐ¼.
    Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ True, ÐµÑÐ»Ð¸ Ñ…Ð¾Ñ‚Ñ Ð±Ñ‹ Ð¾Ð´Ð½Ð° Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ° ÑƒÑÐ¿ÐµÑˆÐ½Ð°.
    """
    if not BOT_TOKEN:
        logger.error("âŒ BOT_TOKEN Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½ Ð² .env Ñ„Ð°Ð¹Ð»Ðµ.")
        return False
    if not is_internet_available():
        logger.warning("âš ï¸ ÐÐµÑ‚ Ð¸Ð½Ñ‚ÐµÑ€Ð½ÐµÑ‚Ð°. ÐŸÑ€Ð¾Ð¿ÑƒÑÐº Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¸ Ð¾Ñ‚Ñ‡ÐµÑ‚Ð°.")
        return False

    user_ids = load_recipients()
    if not user_ids:
        logger.warning("âš ï¸ ÐÐµÑ‚ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹ Ð´Ð»Ñ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¸.")
        return False

    logger.info(f"ðŸ“¤ ÐžÑ‚Ð¿Ñ€Ð°Ð²ÐºÐ° Ð¾Ñ‚Ñ‡ÐµÑ‚Ð° ({len(user_ids)} Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹)...")

    success_count = 0
    with ThreadPoolExecutor(max_workers=min(len(user_ids), 30)) as executor:
        futures = [
            executor.submit(send_to_user, user_id, report_path, user_ids, is_file=True)
            for user_id in user_ids.copy()
        ]

        for future in futures:
            try:
                if future.result():
                    success_count += 1
            except Exception as e:
                logger.error(f"âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð² Ð¿Ð¾Ñ‚Ð¾ÐºÐµ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¸: {e}")

    return success_count > 0
